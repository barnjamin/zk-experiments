import "hashes/sha256/512bit" as hash;
from "utils/casts" import cast;
from "./const" import ShaRngState, SHA_RNG_ROUND_BACK, DIGEST_WORD_NUM, \
                      sha_rng_start_state, ShaDigest, ReadIOP,          \
                      PRIME, Fp, FpExt;
from "./utils" import endian_conv;

// SHA based RNG definitions

def sha_rng_step(ShaRngState mut old_state) -> ShaRngState {
    old_state.pool0 = hash(old_state.pool0, old_state.pool1);
    old_state.pool1 = hash(old_state.pool0, old_state.pool1);
    old_state.cnt = 0;
    return old_state;
}

def sha_rng_incr(ShaRngState mut old_state) -> ShaRngState {
    old_state.cnt = old_state.cnt + 1;
    return if old_state.cnt == SHA_RNG_ROUND_BACK {
        sha_rng_step(old_state)
    } else {
        old_state
    };
}

def sha_rng_next_u32(ShaRngState mut old_state) -> (ShaRngState, u32) {
    u32 mut rand_u32 = old_state.pool0[old_state.cnt];
    old_state = sha_rng_incr(old_state);
    // cast to small endian
    rand_u32 = endian_conv(rand_u32);
    return (old_state, rand_u32);
}

def sha_rng_next_u64(ShaRngState mut old_state) -> (ShaRngState, u64) {
    (ShaRngState, u32) mut temp = sha_rng_next_u32(old_state);
    u32 higher_u32 = temp.1;
    temp = sha_rng_next_u32(temp.0);
    u32 lower_u32 = temp.1;
    u64 rand_u32 = cast([higher_u32, lower_u32]);
    return (temp.0, rand_u32);
}

def sha_rng_mix(ShaRngState mut old_state, ShaDigest digest) -> ShaRngState {
    for u32 i in 0..DIGEST_WORD_NUM {
        old_state.pool0[i] = old_state.pool0[i] ^ digest[i];
    }
    return sha_rng_step(old_state);
}

def sha_rng_sample_fp_raw(ShaRngState mut state) -> (ShaRngState, Fp) {
    Fp mut val = 0;
    for u32 i in 0..6 {
        val = val << 32;
        (ShaRngState, u32) state_and_u32 = sha_rng_next_u32(state);
        state = state_and_u32.0;
        Fp cast_u32 = cast(state_and_u32.1);
        val = val + cast_u32;
        val = val % PRIME;
    }
    return (state, val);
}

def sha_rng_sample_fps_raw<N>(ShaRngState mut state) -> (ShaRngState, Fp[N]) {
    Fp[N] mut res = [0; N];
    for u32 i in 0..N {
        (ShaRngState, u64) intermediate = sha_rng_sample_fp_raw(state);
        state = intermediate.0;
        res[i] = intermediate.1;
    }
    return (state, res);
}

// Read IOP facility definition

// TODO still need the other out and montgomary encoding
def read_iop<N>(u32 mut circuit_outputs, u32[N] mut seal) -> ReadIOP<N> {
    return ReadIOP {
        proof: seal,
        rng_state: sha_rng_start_state(),
        proof_start_from: 0
    };
}

def read_iop_u32s<N, LEN>(ReadIOP<N> mut iop) -> (ReadIOP<N>, u32[LEN]) {
    u32[LEN] mut u32_seg = iop.proof[iop.proof_start_from..iop.proof_start_from + LEN];
    for u32 i in 0..LEN {
        u32_seg[i] = endian_conv(u32_seg[i]);
    }
    iop.proof_start_from = iop.proof_start_from + LEN;
    return (iop, u32_seg);
}

def read_iop_pod_slice<N, P_LEN>(ReadIOP<N> mut iop) -> (ReadIOP<N>, u32[P_LEN]) {
    iop.proof_start_from = iop.proof_start_from + P_LEN;
    u32[P_LEN] pod = \
        iop.proof[iop.proof_start_from..iop.proof_start_from + P_LEN];
    return (iop, pod);
}

def read_iop_commit<N>(ReadIOP<N> mut iop, ShaDigest digest) -> ReadIOP<N> {
    iop.rng_state = sha_rng_mix(iop.rng_state, digest);
    return iop;
}

def read_iop_verify_complete<N>(ReadIOP<N> iop) -> bool {
    return iop.proof_start_from == N;
}

def read_iop_sample_fp_raw<N>(ReadIOP<N> mut iop) -> (ReadIOP<N>, Fp) {
    (ShaRngState, Fp) state_and_u64 = sha_rng_sample_fp_raw(iop.rng_state);
    iop.rng_state = state_and_u64.0;
    return (iop, state_and_u64.1);
}

def read_iop_sample_fps<N, NFs>(ReadIOP<N> mut iop) -> (ReadIOP<N>, Fp[N]) {
    (ShaRngState, Fp[NFs]) mut state_and_samples = \
        sha_rng_sample_fps_raw(iop.rng_state);
    iop.rng_state = state_and_samples.0;
    for u32 i in 0..NFs {
        // TODO to elem conversion
        state_and_samples.1[i] = state_and_samples.1[i];
    }
    return (iop, state_and_samples.1);
}