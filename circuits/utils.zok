from "./const" import PRIME, M_mont, R_2, Fp;

def endian_conv(u32 mut v) -> u32 {
    return (v >> 24) | \
           ((v << 8) & 0x00ff0000) | \
           ((v >> 8) & 0x0000ff00) | (v << 24);
}

def fp_mul(Fp lhs, Fp rhs) -> Fp {
    u64 mut o64 = lhs * rhs;
    u64 cast_down_o64 = o64 % (1u64 << 32);
    u64 low = (-cast_down_o64) % (1u64 << 32);
    u64 red = (M_mont * low) % (1u64 << 32);
    o64 = o64 + red * PRIME;
    Fp ret = o64 >> 32;
    return if ret > PRIME { ret - PRIME } else { ret };
}

def encode_mont(u64 a) -> Fp {
    return fp_mul(R_2, a);
}

def decode_mont(Fp a) -> u64 {
    return fp_mul(1, a);
}

def fp_add(Fp lhs, Fp rhs) -> Fp {
    Fp mut x = (lhs + rhs) % (1u64 << 32);
    return if x < PRIME { x } else { (x - PRIME) % (1u64 << 32) };
}

def fp_sub(Fp lhs, Fp rhs) -> Fp {
    Fp mut x = (lhs - rhs) % (1u64 << 32);
    return if x > PRIME { (x + PRIME) % (1u64 << 32) } else { x };
}

def to_Fp(u64 raw) -> Fp {
    return encode_mont(raw % PRIME);
}

def fp_pow(Fp base, u64 exp) -> Fp {
    Fp mut total = to_Fp(1);
    Fp mut x = base;
    u64 mut mask = 1;
    for u32 i in 0..64 {
        total = if (mask & exp) > 0 { fp_mul(total, x) } else { total };
        mask = mask << 1;
        x = fp_mul(x, x);
    }
    return total;
}

def fp_inv(Fp fp) -> Fp {
    return fp_pow(fp, PRIME - 2);
}
