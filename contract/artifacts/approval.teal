#pragma version 8
intcblock 0 1 64 32 448
bytecblock 0x766b 0x151f7c75 0x
txn NumAppArgs
intc_0 // 0
==
bnz main_l8
txna ApplicationArgs 0
pushbytes 0x793ae44d // "bootstrap((byte[32][2],byte[32][2][2],byte[32][2][2],byte[32][2][2],byte[32][2][2]))void"
==
bnz main_l7
txna ApplicationArgs 0
pushbytes 0x8b7371da // "verify(byte[32][],(byte[32][2],byte[32][2][2],byte[32][2]))bool"
==
bnz main_l6
txna ApplicationArgs 0
pushbytes 0x59c3b0a7 // "get_vk()(byte[32][2],byte[32][2][2],byte[32][2][2],byte[32][2][2],byte[32][2][2])"
==
bnz main_l5
err
main_l5:
txn OnCompletion
intc_0 // NoOp
==
txn ApplicationID
intc_0 // 0
!=
&&
assert
callsub getvk_11
store 16
bytec_1 // 0x151f7c75
load 16
concat
log
intc_1 // 1
return
main_l6:
txn OnCompletion
intc_0 // NoOp
==
txn ApplicationID
intc_0 // 0
!=
&&
assert
txna ApplicationArgs 1
store 0
txna ApplicationArgs 2
store 1
load 0
load 1
callsub verify_10
store 2
bytec_1 // 0x151f7c75
pushbytes 0x00 // 0x00
intc_0 // 0
load 2
setbit
concat
log
intc_1 // 1
return
main_l7:
txn OnCompletion
intc_0 // NoOp
==
txn ApplicationID
intc_0 // 0
!=
&&
assert
txna ApplicationArgs 1
callsub bootstrap_9
intc_1 // 1
return
main_l8:
txn OnCompletion
intc_0 // NoOp
==
bnz main_l10
err
main_l10:
txn ApplicationID
intc_0 // 0
==
assert
callsub create_0
intc_1 // 1
return

// create
create_0:
intc_1 // 1
return

// add
add_1:
callsub curveadd_6
retsub

// scale
scale_2:
callsub curvescalarmul_7
retsub

// check_proof_values
checkproofvalues_3:
store 20
intc_1 // 1
retsub

// compute_linear_combination
computelinearcombination_4:
store 10
store 9
pushbytes 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 // 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
store 11
intc_0 // 0
store 13
computelinearcombination_4_l1:
load 13
load 10
intc_0 // 0
extract_uint16
<
bz computelinearcombination_4_l3
load 10
intc_3 // 32
load 13
*
pushint 2 // 2
+
intc_3 // 32
extract3
store 14
load 14
pushbytes 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001 // 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001
b<
// verifier gte snark scalar
assert
load 9
intc 4 // 448
dig 1
len
substring3
intc_2 // 64
load 13
intc_1 // 1
+
*
intc_2 // 64
extract3
load 14
callsub scale_2
store 12
load 11
load 12
callsub add_1
store 11
load 13
intc_1 // 1
+
store 13
b computelinearcombination_4_l1
computelinearcombination_4_l3:
load 9
intc 4 // 448
dig 1
len
substring3
intc_2 // 64
intc_0 // 0
*
intc_2 // 64
extract3
store 15
load 11
load 15
callsub add_1
store 11
load 11
retsub

// valid_pairing
validpairing_5:
store 23
store 22
store 21
bytec_2 // ""
store 24
bytec_2 // ""
store 25
intc_1 // 1
retsub

// curve_add
curveadd_6:
ec_add
retsub

// curve_scalar_mul
curvescalarmul_7:
ec_scalar_mul
retsub

// auth_only
authonly_8:
global CreatorAddress
==
retsub

// bootstrap
bootstrap_9:
store 19
txn Sender
callsub authonly_8
// unauthorized
assert
bytec_0 // "vk"
load 19
box_put
retsub

// verify
verify_10:
store 4
store 3
load 4
callsub checkproofvalues_3
// A value in the proof was > PrimeQ
assert
bytec_0 // "vk"
box_get
store 7
store 6
load 7
// Verification Key not set
assert
load 6
store 5
load 5
load 3
callsub computelinearcombination_4
store 8
load 4
load 5
load 8
callsub validpairing_5
!
!
retsub

// get_vk
getvk_11:
bytec_0 // "vk"
box_get
store 18
store 17
load 18
// Verification Key not set
assert
load 17
retsub