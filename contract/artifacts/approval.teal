#pragma version 8
intcblock 0 1 64 32 448
bytecblock 0x766b 0x151f7c75 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47
txn NumAppArgs
intc_0 // 0
==
bnz main_l8
txna ApplicationArgs 0
pushbytes 0x793ae44d // "bootstrap((byte[32][2],byte[32][2][2],byte[32][2][2],byte[32][2][2],byte[32][2][2]))void"
==
bnz main_l7
txna ApplicationArgs 0
pushbytes 0x8b7371da // "verify(byte[32][],(byte[32][2],byte[32][2][2],byte[32][2]))bool"
==
bnz main_l6
txna ApplicationArgs 0
pushbytes 0x59c3b0a7 // "get_vk()(byte[32][2],byte[32][2][2],byte[32][2][2],byte[32][2][2],byte[32][2][2])"
==
bnz main_l5
err
main_l5:
txn OnCompletion
intc_0 // NoOp
==
txn ApplicationID
intc_0 // 0
!=
&&
assert
callsub getvk_13
store 16
bytec_1 // 0x151f7c75
load 16
concat
log
intc_1 // 1
return
main_l6:
txn OnCompletion
intc_0 // NoOp
==
txn ApplicationID
intc_0 // 0
!=
&&
assert
txna ApplicationArgs 1
store 0
txna ApplicationArgs 2
store 1
load 0
load 1
callsub verify_12
store 2
bytec_1 // 0x151f7c75
pushbytes 0x00 // 0x00
intc_0 // 0
load 2
setbit
concat
log
intc_1 // 1
return
main_l7:
txn OnCompletion
intc_0 // NoOp
==
txn ApplicationID
intc_0 // 0
!=
&&
assert
txna ApplicationArgs 1
callsub bootstrap_11
intc_1 // 1
return
main_l8:
txn OnCompletion
intc_0 // NoOp
==
bnz main_l10
err
main_l10:
txn ApplicationID
intc_0 // 0
==
assert
callsub create_0
intc_1 // 1
return

// create
create_0:
intc_1 // 1
return

// add
add_1:
callsub curveadd_7
retsub

// scale
scale_2:
callsub curvescalarmul_8
retsub

// negate
negate_3:
store 31
load 31
bytec_2 // 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
b==
bnz negate_3_l2
load 31
bytec_3 // 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47
load 31
extract 32 0
bytec_3 // 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47
b%
b-
replace2 32
b negate_3_l3
negate_3_l2:
load 31
negate_3_l3:
retsub

// check_proof_values
checkproofvalues_4:
store 20
intc_1 // 1
retsub

// compute_linear_combination
computelinearcombination_5:
store 10
store 9
bytec_2 // 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
store 11
intc_0 // 0
store 13
computelinearcombination_5_l1:
load 13
load 10
intc_0 // 0
extract_uint16
<
bz computelinearcombination_5_l3
load 10
intc_3 // 32
load 13
*
pushint 2 // 2
+
intc_3 // 32
extract3
store 14
load 14
pushbytes 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001 // 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001
b<
// verifier gte snark scalar
assert
load 9
intc 4 // 448
dig 1
len
substring3
intc_2 // 64
load 13
intc_1 // 1
+
*
intc_2 // 64
extract3
load 14
callsub scale_2
store 12
load 11
load 12
callsub add_1
store 11
load 13
intc_1 // 1
+
store 13
b computelinearcombination_5_l1
computelinearcombination_5_l3:
load 9
intc 4 // 448
dig 1
len
substring3
intc_2 // 64
intc_0 // 0
*
intc_2 // 64
extract3
store 15
load 11
load 15
callsub add_1
store 11
load 11
retsub

// valid_pairing
validpairing_6:
store 23
store 22
store 21
load 21
extract 0 64
callsub negate_3
store 24
load 22
extract 0 64
store 26
load 24
load 26
concat
store 24
load 24
load 23
concat
store 24
load 21
extract 192 0
store 27
load 24
load 27
concat
store 24
load 21
extract 64 128
store 25
load 22
extract 64 128
store 28
load 25
load 28
concat
store 25
load 22
extract 192 128
store 29
load 25
load 29
concat
store 25
load 22
pushint 320 // 320
pushint 128 // 128
extract3
store 30
load 25
load 30
concat
store 25
load 24
load 25
callsub curvepairing_9
retsub

// curve_add
curveadd_7:
ec_add BN254_G1
retsub

// curve_scalar_mul
curvescalarmul_8:
ec_scalar_mul BN254_G1
retsub

// curve_pairing
curvepairing_9:
ec_pairing BN254_G1
retsub

// auth_only
authonly_10:
global CreatorAddress
==
retsub

// bootstrap
bootstrap_11:
store 19
txn Sender
callsub authonly_10
// unauthorized
assert
bytec_0 // "vk"
load 19
box_put
retsub

// verify
verify_12:
store 4
store 3
load 4
callsub checkproofvalues_4
// A value in the proof was > PrimeQ
assert
bytec_0 // "vk"
box_get
store 7
store 6
load 7
// Verification Key not set
assert
load 6
store 5
load 5
load 3
callsub computelinearcombination_5
store 8
load 4
load 5
load 8
callsub validpairing_6
!
!
retsub

// get_vk
getvk_13:
bytec_0 // "vk"
box_get
store 18
store 17
load 18
// Verification Key not set
assert
load 17
retsub