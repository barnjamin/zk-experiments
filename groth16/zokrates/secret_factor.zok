def reveal(u64 hidden_factor) -> u64 {
    u64 random_summand = 15825923428474158623;
    return hidden_factor - random_summand;
}

def main(u64 hidden_factor) {
    u64 composite = 1698269078375486647;
    u64 factor = reveal(hidden_factor);

    assert(1 < factor && factor < composite && composite % factor == 0);
    return;
}


/**********

One day, when:
* there is a circuit for ed25519.encrypt()
* we have native encryption/decryption
then the following may be possible...

def future_reveal(cipherType hidden_factor) -> msgType {
    return receiver_secret_decrypt_key.decrypt(hidden_factor)
}

Current state seems to only have a circuit for ed25519.sign() and it is quite large: https://github.com/Electron-Labs/ed25519-circom#benchmarks
There is a proposal (ARC-15) to have public key _encryption_ on Algorand but it is problematic: https://github.com/algorandfoundation/ARCs/pull/49

***********/